/*******************************************************************************
 *
 * Pentaho Data Integration
 *
 * Copyright (C) 2002-2012 by Pentaho : http://www.pentaho.com
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package com.ucuenca.pentaho.plugin.step;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.RandomAccessFile;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.row.RowDataUtil;
import org.pentaho.di.core.row.RowMeta;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;

//-----------------------
import org.apache.jena.atlas.lib.FileOps;
import org.apache.jena.fuseki.Fuseki;
import org.apache.jena.fuseki.server.FusekiVocab;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.MessageBox;
import org.eclipse.swt.widgets.Shell;

import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.ontology.OntModelSpec;
import com.hp.hpl.jena.query.DatasetFactory;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QueryExecutionFactory;
import com.hp.hpl.jena.query.QueryFactory;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ReadWrite;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.query.ResultSetFormatter;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.ResourceFactory;
import com.hp.hpl.jena.sparql.core.DatasetGraph;
import com.hp.hpl.jena.tdb.TDBFactory;
import com.hp.hpl.jena.tdb.base.file.Location;
import com.hp.hpl.jena.vocabulary.RDF;
import com.hp.hpl.jena.vocabulary.RDFS;
import com.hp.hpl.jena.query.Dataset;

import com.hp.hpl.jena.vocabulary.*;

//-------------------librerias XML
import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

//-------------------

/** .
 * @author Fabian Peñaloza Marin
 * @version 1
 */
/**
 * This class is part of the demo step plug-in implementation. It demonstrates
 * the basics of developing a plug-in step for PDI.
 * 
 * The demo step adds a new string field to the row stream and sets its value to
 * "Hello World!". The user may select the name of the new field.
 * 
 * This class is the implementation of StepInterface. Classes implementing this
 * interface need to:
 * 
 * - initialize the step - execute the row processing logic - dispose of the
 * step
 * 
 * Please do not create any local fields in a StepInterface class. Store any
 * information related to the processing logic in the supplied step data
 * interface instead.
 * 
 */

public class EldaPDIStep extends BaseStep implements StepInterface {

	private Model fModel = ModelFactory.createDefaultModel();
	private String  nombreConfiguracion  = "";   //nombre para crear la configuracion
	List<String> myListProper;
	List<String> myListProperNames;
	String simboloSeparar = "/";
	/**
	 * The constructor should simply pass on its arguments to the parent class.
	 * 
	 * @param s
	 *            step description
	 * @param stepDataInterface
	 *            step data class
	 * @param c
	 *            step copy
	 * @param t
	 *            transformation description
	 * @param dis
	 *            transformation executing
	 */
	public EldaPDIStep(StepMeta s, StepDataInterface stepDataInterface, int c,
			TransMeta t, Trans dis) {
		super(s, stepDataInterface, c, t, dis);
	}

	/**
	 * This method is called by PDI during transformation startup.
	 * 
	 * It should initialize required for step execution.
	 * 
	 * The meta and data implementations passed in can safely be cast to the
	 * step's respective implementations.
	 * 
	 * It is mandatory that super.init() is called to ensure correct behavior.
	 * 
	 * Typical tasks executed here are establishing the connection to a
	 * database, as wall as obtaining resources, like file handles.
	 * 
	 * @param smi
	 *            step meta interface implementation, containing the step
	 *            settings
	 * @param sdi
	 *            step data interface implementation, used to store runtime
	 *            information
	 * 
	 * @return true if initialization completed successfully, false if there was
	 *         an error preventing the step from working.
	 * 
	 */
	/*
	 * public boolean init(StepMetaInterface smi, StepDataInterface sdi) { //
	 * Casting to step-specific implementation classes is safe FusekiLoaderMeta
	 * meta = (FusekiLoaderMeta) smi; FusekiLoaderData data = (FusekiLoaderData)
	 * sdi;
	 * 
	 * return super.init(meta, data); }
	 */
	/**
	 * Once the transformation starts executing, the processRow() method is
	 * called repeatedly by PDI for as long as it returns true. To indicate that
	 * a step has finished processing rows this method must call setOutputDone()
	 * and return false;
	 * 
	 * Steps which process incoming rows typically call getRow() to read a
	 * single row from the input stream, change or add row content, call
	 * putRow() to pass the changed row on and return true. If getRow() returns
	 * null, no more rows are expected to come in, and the processRow()
	 * implementation calls setOutputDone() and returns false to indicate that
	 * it is done too.
	 * 
	 * Steps which generate rows typically construct a new row Object[] using a
	 * call to RowDataUtil.allocateRowData(numberOfFields), add row content, and
	 * call putRow() to pass the new row on. Above process may happen in a loop
	 * to generate multiple rows, at the end of which processRow() would call
	 * setOutputDone() and return false;
	 * 
	 * @param smi
	 *            the step meta interface containing the step settings
	 * @param sdi
	 *            the step data interface that should be used to store
	 * 
	 * @return true to indicate that the function should be called again, false
	 *         if the step is done
	 */
	public boolean processRow(StepMetaInterface smi, StepDataInterface sdi)
			throws KettleException {

		// safely cast the step settings (meta) and runtime info (data) to
		// specific implementations
		EldaPDIStepMeta meta = (EldaPDIStepMeta) smi;
		EldaPDIStepData data = (EldaPDIStepData) sdi;
		getRow();
		String status = "ERROR";
		if (meta.getValidate().equals("true")) {
			// the "first" flag is inherited from the base step implementation
			// it is used to guard some processing tasks, like figuring out
			// field
			// indexes
			// in the row structure that only need to be done once
			if (first) {
				first = false;

				super.init(meta, data);
				data.outputRowMeta = getInputRowMeta() != null ? getInputRowMeta()
						.clone() : new RowMeta();
				// data.outputRowMeta = (RowMetaInterface)
				// getInputRowMeta().clone();
				try {
					data.model.read(meta.getOutputField().trim());

				} catch (Exception eox) {
					logBasic(" ERROR " + eox + " Unload model "
							+ meta.getOutputField());
				}
				//tranformacion a dataset
				String name = meta.getInputName().replaceFirst("[.][^.]+$", ""); 
				
				
				 nombreConfiguracion = ObtenerNombreUrl(meta.getEbaseUri());

				
				String FileName = nombreConfiguracion+".ttl";
				
				// create mapping.ttl-------------------------------------
				
				
				createmapping(meta, FileName);

				logBasic(" config data is ok ");

				try {
					/**
					 * File source=new
					 * File("plugins/steps/FusekiLoader/fuseki.war"); File
					 * destination=new File(meta.getDirectory()+"/fuseki.war");
					 */

					// create destination
					File dir = new File(meta.getDirectory() + "/elda");
					dir.mkdir();
					//
					File source = new File("plugins/steps/EldaLoader/elda");
					File destination = new File(meta.getDirectory() + "/elda");

					recursiveCopy(source, destination);
					
					//configurar base URI   name
					parametrizarUri(source, destination, nombreConfiguracion);
					
					// copyFile(source,destination);
					// crear war
					crearwar(destination.toString());

					logBasic("The elda was build succesfully in "
							+ meta.getDirectory() + "/" + "elda");

				} catch (Exception e1) {

					logBasic(" ERROR " + e1 + "The File was not created. in "
							+ meta.getDirectory() + "/" + "elda");
				}

			}


			status = "OK";


			Object[] outputRow = new Object[2];

			outputRow[0] = meta.getDirectory() + "/elda";
			outputRow[1] = status;
			putRow(data.outputRowMeta, outputRow);

			// log progress if it is time to to so
			if (checkFeedback(getLinesRead())) {
				logBasic("Linenr " + getLinesRead()); // Some basic logging
			}
		} else {

			logBasic(" ERROR Tranformation dont started , because parameters es empty");

			status = "ERROR";
		}
		// indicate that processRow() should be called again
		return false;
	}
	
	private void AgregarParametroWeb(String name) {
		
		 try {
				String filepath = "plugins/steps/EldaLoader/elda/webapps/ROOT/WEB-INF/web.xml";
				DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
				DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
				Document doc = docBuilder.parse(filepath);
				
				
				// Get the root element
				Node principal = doc.getFirstChild();
				
				Node staff = doc.getElementsByTagName("param-value").item(0);
				
				
				Element age = doc.createElement(name+"::/specs/"+name+".ttl");
				staff.appendChild(age);
				
				
				// write the content into xml file
				TransformerFactory transformerFactory = TransformerFactory.newInstance();
				Transformer transformer = transformerFactory.newTransformer();
				DOMSource source = new DOMSource(doc);
				StreamResult result = new StreamResult(new File(filepath));
				transformer.transform(source, result);

				System.out.println("Done");
				
		 } catch (ParserConfigurationException pce) {
				pce.printStackTrace();
			   } catch (TransformerException tfe) {
				tfe.printStackTrace();
			   } catch (IOException ioe) {
				ioe.printStackTrace();
			   } catch (SAXException sae) {
				sae.printStackTrace();
			   }
	}

	/**
	 * MEtodo necesario para obtener el nombre a configurar en el web.xml
	 * @param ebaseUri
	 * @return String del nombre ultimo del url
	 */
	private String ObtenerNombreUrl(String ebaseUri) {
		String resp= "";
		
		//System.out.println("base Uri "+ebaseUri);
		for(int i=ebaseUri.length()-1; i>=0;i--){
			//System.out.println("i  "+i + " "+ebaseUri.substring(i,i));
		    if (ebaseUri.substring(i,i+1).compareTo("/")!=0){
		    	resp = ebaseUri.substring(i,i+1)+resp;
		    }else if(i!=ebaseUri.length()-1){
		    	i=-1; //termino de concatenar
		    }
		  }
		
		//System.out.println("base urif "+resp);
		return resp;
	}
	/**
	 * Metodo con la logica que crea el archivo de mapeo para la configuracion de elda
	 * @param meta
	 * @param FileName
	 */
	private void createmapping(EldaPDIStepMeta meta,String FileName) {
		List<String> myListSelect;
		myListSelect = cleanspaces(meta.getListSelect()); //lista de entidades		
		
		//List<String> myListProper;
		myListProper = cleanspaces(meta.getListProper());
		
		List<String> myListSelectNames;
		myListSelectNames = cargaListaTodos(meta.getListSelectNames());//myListSelectNames = cleanspaces(meta.getListSelectNames());
		
		//List<String> myListProperNames;
		myListProperNames = cargaListaTodos(meta.getListProperNames());
		
		List<String> myListLabelXEntidad;
		myListLabelXEntidad = cargaListaTodos(meta.getListLabelxEntidad());
		
		int val = 99;

		logBasic(" llego al mapping " + meta.getInputName());

		// conf principal

		// API END POINT

		 		//nombre "example-data.ttl"; Resource subresL = fModel.createResource("local:data/" + nombre);
		logBasic(" sparqlEndpoint : " + meta.getServicio());
		Resource subresL = fModel.createResource(meta.getServicio());   //poner la url del servicio 
		
		//String urlconfig = meta.getEbaseUri(); .createResource(
	//"http://epimorphics.com/public/vocabulary/games.ttl#hello-world")
		logBasic(" URL configuracion : " + meta.getEbaseUri());
		String URLconfiguracion = meta.getEbaseUri();
		
		
		
		Resource resourcePrin = fModel
				.createResource(
						URLconfiguracion + nombreConfiguracion) //"#"+
				.addProperty(RDF.type, api.API)
				.addProperty(api.sparqlEndpoint, subresL)
				.addProperty(api.defaultViewer, api.labelledDescribeViewer)
				.addProperty(
						api.viewer,
						fModel.createResource()
								.addProperty(RDF.type, api.Viewer)
								.addProperty(api.name, "empty")
								.addProperty(api.properties, ""))
				.addProperty(
						api.variable,
						fModel.createResource()
								.addProperty(api.name, "_velocityRoot")
								.addProperty(api.value,
										"http://localhost:8080/lda-assets/vm/")) //http://localhost:8080/standalone/lda-assets/vm/
				.addProperty(
						api.variable,
						fModel.createResource()
								.addProperty(api.name, "_resourceRoot")
								.addProperty(api.value,
										"/lda-assets/")) ///standalone/lda-assets/
				/*.addProperty(api.endpoint,
						"http://epimorphics.com/public/vocabulary/games.ttl#publisher")
				.addProperty(api.endpoint,
						"http://epimorphics.com/public/vocabulary/games.ttl#games")
				.addProperty(api.endpoint,
						"http://epimorphics.com/public/vocabulary/games.ttl#about")*/

				
				//VelocityFormatter
				/*						
				.addProperty(
						api.formatter,
						fModel.createResource()
								.addProperty(RDF.type, elda.VelocityFormatter)
								.addProperty(api.name, "vhtml")
								.addProperty(elda.className,
										"com.epimorphics.lda.renderers.VelocityRendererFactory")
								.addProperty(api.mimeType,
										"text/html")
								.addProperty(elda.velocityTemplate,
										"page-shell.vm"))
				*/
				
			//cambio formater
										//opcional formater para Atom Xslt Formatter
				.addProperty(
						api.formatter,
						fModel.createResource()	
						.addProperty(RDF.type, api.XsltFormatter)
						.addProperty(api.name, "html")
						.addProperty(api.mimeType, "text/html; charset=utf-8")
						.addProperty(api.stylesheet, "lda-assets/xslt/result-osm-trimmed.xsl")
						)
										
										
				// Atom Formatter   Feed Formater
								 
					.addProperty(
						api.formatter,
						fModel.createResource()
								.addProperty(RDF.type, elda.FeedFormatter)
								.addProperty(api.name, "atom")
								.addProperty(elda.className,
										"com.epimorphics.lda.renderers.FeedRendererFactory")
								.addProperty(api.mimeType,
										"application/atom+xml")
								.addProperty(elda.feedTitle, "an example Elda feed")		
							)						
					
										
										
				.addProperty(elda.enableCounting, "true")
				.addProperty(elda.cacheExpiryTime, "1m")
				.addProperty(elda.graphTemplate, meta.getEbaseUri());
				
				
				//formater css 
		
		
;
//crear viewerMedium
Resource rvierwerMedium = fModel
.createResource( URLconfiguracion+"viewerMedium");

rvierwerMedium.addProperty(RDF.type, api.Viewer)
.addProperty(api.name, "medium")
;

//listPoint Configurations Entidades
		for (int i=0 ; i<myListSelect.size(); i++){
			// listPoint hello:publishers
			String nlabel = myListSelect.get(i).substring(myListSelect.get(i).lastIndexOf("#")+1, myListSelect.get(i).length());
			if (nlabel.length() == myListSelect.get(i).length()){ nlabel = myListSelect.get(i).substring(myListSelect.get(i).lastIndexOf("/")+1, myListSelect.get(i).length());
			 }
			String namer = URLconfiguracion + nlabel.toLowerCase(); //String namer = (myListSelect.get(i)+"s").toLowerCase();   "#"+
			System.out.println(nlabel+ " "+namer);
			String nombreURI = "";
			//revisar si el usuario puso un nombre
			if (myListSelectNames.get(i).trim().isEmpty() || (myListSelectNames.get(i)==null)){
				nombreURI = "/"+nlabel ; //nombreURI = "/"+nlabel.toLowerCase()+"s" ;
			}else {
				nombreURI = "/"+myListSelectNames.get(i).trim();
			}
			
			String propiedadSort="";
			if (myListLabelXEntidad.get(i).trim().isEmpty()){
				propiedadSort = "label" ;
			}else{
			 propiedadSort = obtenerLabelPropiedadSort(myListLabelXEntidad.get(i));
			}
			
			Resource resourceL = fModel
					.createResource(namer);
			resourceL
					.addProperty(RDF.type, api.ListEndpoint)
					.addProperty(RDFS.label, Character.toUpperCase(nlabel.charAt(0)) + nlabel.substring(1) ) //.addProperty(RDFS.label, myListLabelXEntidad nlabel+'s') LABEL X ENTIDAD
					.addProperty(api.uriTemplate, nombreURI) 
					.addProperty(
							api.selector,
							fModel.createResource()
									.addProperty(api.filter, "type="+nlabel)
									.addProperty(api.sort, quitaEspacios(propiedadSort) )) //.addProperty(api.sort, "label"))
					.addProperty(api.defaultViewer, rvierwerMedium);//
					//.addProperty(api.defaultViewer, api.labelledDescribeViewer);
			
			resourcePrin.addProperty(api.endpoint,resourceL);  //agregar listEnpoint al resource principal
			
			//class

			Resource resourceC = fModel
					.createResource(
							myListSelect.get(i))
					.addProperty(RDF.type, RDFS.Class)
					.addProperty(api.label, nlabel);
			;
			
			//creacion de itemEndpoints x entidad muestreo
			
			//ObtenerListaMuestreo(meta.getServicio(), meta.getEbaseUri(), myListSelect.get(i));
			ArrayList<String> listaTiposPorEntidad = new ArrayList<String>();
			ArrayList<String> listaUrisTodosTipos = new ArrayList<String>();
			listaTiposPorEntidad = ObtenerTiposEntidad(meta.getServicio(), meta.getEbaseUri(), myListSelect.get(i));
			
			System.out.println("//////////////// tamaño lista tipo entidad   "+listaTiposPorEntidad.size());
			System.out.println("//////////////// lista tipo entidad  "+listaTiposPorEntidad);
			for (int k=0;k<listaTiposPorEntidad.size();k++){
				listaUrisTodosTipos.addAll(ObtenerMuestreoXTipoEntidad(meta.getServicio(), meta.getEbaseUri(),listaTiposPorEntidad.get(k).trim()));
				//ObtenerMuestreoXTipoEntidad(meta.getServicio(), meta.getEbaseUri(),listaTiposPorEntidad.get(k).trim());
			}
			
			//si no hay tipos por entidad hago un muestreo normal y lo cargo 
			if (listaTiposPorEntidad.size()==0){ listaUrisTodosTipos = ObtenerListaMuestreo(meta.getServicio(), meta.getEbaseUri(), myListSelect.get(i)); }
			
			//configuracion itemEndpoint
			
			ArrayList<String> filtrosEndpoint = new ArrayList<String>();
			filtrosEndpoint = obtenerParametrosFiltros(listaUrisTodosTipos,meta.getEbaseUri()); //filtrosEndpoint = obtenerParametrosFiltros(ObtenerListaMuestreo(meta.getServicio(), meta.getEbaseUri(), myListSelect.get(i)),meta.getEbaseUri());
			String uriTemplate = crearUriTemplate(filtrosEndpoint);
			String apiWhere = crearApiWhere(filtrosEndpoint,myListSelect.get(i)) ; // filtros, ds
			
			Resource resourceE = fModel
					//.createResource("http://epimorphics.com/public/vocabulary/games.ttl#about");
					.createResource(namer+"reg"); //   ejemplo personreg
			resourceE.addProperty(RDF.type, api.ItemEndpoint)
			.addProperty(RDFS.label,"Sobre "+nlabel+'s')
			.addProperty(api.uriTemplate, uriTemplate)
			//.addProperty(api.itemTemplate, "{uri}")
			.addProperty(api.variable, 
					fModel.createResource()			
					.addProperty(api.name,"item")
					.addProperty(api.type,RDFS.Resource))
			.addProperty(api.selector, fModel.createResource()
					.addProperty(api.where, apiWhere)
					.addProperty(api.sort, "label")
					)	
			//.addProperty(api.defaultViewer, rvierwerMedium) //api.labelledDescribeViewer	
			.addProperty(api.defaultViewer, api.labelledDescribeViewer);
			;
			resourcePrin.addProperty(api.endpoint,resourceE);
			
		}
		
		
		
		
		
		
		
		// ItemEndpoint About 
	/*	Resource resourceE = fModel
				//.createResource("http://epimorphics.com/public/vocabulary/games.ttl#about");
				.createResource(URLconfiguracion +"about"); //#
		resourceE.addProperty(RDF.type, api.ItemEndpoint)
		.addProperty(RDFS.label,"About")
		.addProperty(api.uriTemplate, "/about?resource={uri}")
		.addProperty(api.itemTemplate, "{uri}")
		.addProperty(api.variable, 
				fModel.createResource()
				.addProperty(api.name,fModel.createResource()
						.addProperty(api.type,RDFS.Resource))
				)
		.addProperty(api.selector, fModel.createResource()
				.addProperty(api.where, "?item ?p ?o. FILTER(?item = ?uri)")
				.addProperty(api.sort, "label")
				)	
		.addProperty(api.defaultViewer,api.labelledDescribeViewer)		
		;
		resourcePrin.addProperty(api.endpoint,resourceE); */
		
		// configuracion propiedades 
		for (int k=0 ; k<myListProper.size(); k++){
			String nlabel = "";
			//validacion url vacia
			if (!myListProper.get(k).isEmpty()){
				if (myListProperNames.size() > k){
					 if(myListProperNames.get(k).trim().isEmpty() || (myListProperNames.get(k).trim()==null))
					 {	//si esta vacio lo ingreso por defecto  
						 nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("#")+1, myListProper.get(k).length());
						if (nlabel.length() == myListProper.get(k).length()){ nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("/")+1, myListProper.get(k).length());
						 }
					 }else{
						 nlabel = myListProperNames.get(k).trim();
					 }
				}else {
					 nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("#")+1, myListProper.get(k).length());
						if (nlabel.length() == myListProper.get(k).length()){ nlabel = myListProper.get(k).substring(myListProper.get(k).lastIndexOf("/")+1, myListProper.get(k).length());
						 }
				}
					 
				// propiedad
				Resource resourceP = fModel
						.createResource(myListProper.get(k));
				resourceP.addProperty(RDF.type, RDF.Property).addProperty(api.label,
						quitaEspacios(nlabel));
				
				rvierwerMedium.addProperty(api.properties, quitaEspacios(nlabel)) ; //agrego propiedad al 	viewer medium
				
			}
		}
		
		 //agrego viewerMedium al modelo principal
		
		
		// resourceC.addProperty(RDFS.class, "#publisher")
		
		//opcional formater para Atom Xslt Formatter
		/*
		Resource resourceFormato = fModel
				.createResource(
						URLconfiguracion + "#"+"HtmlFormatter")
				.addProperty(RDF.type, api.XsltFormatter)
				.addProperty(api.name, "html")
				.addProperty(api.mimeType, "text/html; charset=utf-8")
				.addProperty(api.stylesheet, "lda-assets/xslt/result-osm-trimmed.xsl");
		resourcePrin.addProperty(api.defaultFormatter,resourceFormato);		
	*/
		//creo prefix 
		fModel.setNsPrefix(nombreConfiguracion, meta.getEbaseUri());//+"#"
		fModel.setNsPrefix("api", "http://purl.org/linked-data/api/vocab#");
		fModel.setNsPrefix("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
		fModel.setNsPrefix("rdfs", "http://www.w3.org/2000/01/rdf-schema#");
		fModel.setNsPrefix("xsd", "http://www.w3.org/2001/XMLSchema#");
		fModel.setNsPrefix("elda", "http://www.epimorphics.com/vocabularies/lda#");
		
		
		
		
		
		FileWriter out;
		try {
			
//			out = new FileWriter("plugins/steps/EldaLoader/elda/webapps/standalone/specs/"
//					+ FileName);
			
			out = new FileWriter("plugins/steps/EldaLoader/elda/webapps/ROOT/specs/"
					+ FileName);
			
			
			OutputStream out2 = new FileOutputStream("plugins/steps/EldaLoader/elda/webapps/ROOT/specs/"
					+ FileName);
			
			fModel.write(out2, "TURTLE"); //escribo el modelo en un archivo
			logBasic( "The File config "+FileName+" was  created ");
			

		} catch (IOException e) {

			logBasic(e.toString());

		}

		try {
			
			//limpieza de los strings
			
			String line = "", oldtext = "";
			
			
			//OutputStream out2 = new FileOutputStream("plugins/steps/EldaLoader/elda/webapps/ROOT/specs/"
			//		+  "2"+FileName);
			
			File file = new File("plugins/steps/EldaLoader/elda/webapps/ROOT/specs/"+FileName);
			BufferedReader reader2 = new BufferedReader(new FileReader(file));
			String line2 = "", oldtext2 = "";
			while ((line2 = reader2.readLine()) != null) {  
				String linea="";
				for (int i=0; i<line2.length();i++){   //limpieza 1
					String car= line2.substring(i, i+1);
					if (car.compareTo("\\")!=0){
						linea += car;
					}
				}
				
				//limpieza2 '"
				String lineaLimpia = "";  
				lineaLimpia = linea.replaceAll("'\"", "'");
				lineaLimpia = lineaLimpia.replaceAll("\"'", "'");
				/*
				int indice=0;
				 for (int i=0; i<linea.length();i++){
					 indice= i+2;
					 if((i+2)>linea.length()){ indice=i+1;}
					 String car= linea.substring(i, indice);
						if ((car.compareTo("\"'")!=0) && (car.compareTo("'\"")!=0) ){
							lineaLimpia += car;
						}else{
							lineaLimpia += "'";
						}
						i++;
				 }*/
				
				oldtext2 += lineaLimpia + "\r\n";
			}
			reader2.close();

			String newtext = oldtext2;
			
			FileWriter writer = new FileWriter(
					"plugins/steps/EldaLoader/elda/webapps/ROOT/specs/" + FileName);
			writer.write(newtext);
			
			writer.close();
			
		} catch (IOException ioe) {
			logBasic(" ERROR " + ioe + "The File config "+FileName+" was not created. ");
			ioe.printStackTrace();

		}

	}
	
	
	/**
	 * 
	 * @param myListProperNames 
	 * @param myListProper 
	 * @param propiedadSort
	 * @return
	 */
	private String obtenerLabelPropiedadSort(String propiedadSort) {
		// TODO Auto-generated method stub
		String resp="";
		Boolean encontro = false;
		Boolean tieneLabel = false;
		//confirmo si la propiedad tiene label
		for (int i=0;i<myListProper.size();i++){
			if(propiedadSort.trim().compareTo(myListProper.get(i).trim())==0){
				encontro=true;
				if (!myListProperNames.get(i).trim().isEmpty()){ //tiene nombre
					tieneLabel= true;
					resp= myListProperNames.get(i).trim();
				}else{
					resp = myListProper.get(i).substring(myListProper.get(i).lastIndexOf("#")+1, myListProper.get(i).length());
					if (resp.length() == myListProper.get(i).length()) {
						resp = myListProper.get(i).substring(
								myListProper.get(i).lastIndexOf("/") + 1,
								myListProper.get(i).length());
					}
				}
			}
			
		}
		
		//si no habia propiedad la ingreso en la lista para que sea creada
		if (!encontro){
			myListProper.add(propiedadSort.trim());
			resp = propiedadSort.substring(propiedadSort.lastIndexOf("#")+1, propiedadSort.length());
			if (resp.length() == propiedadSort.length()) {
				resp = propiedadSort.substring(
						propiedadSort.lastIndexOf("/") + 1,
						propiedadSort.length());
			}
			myListProperNames.add(resp);
		}
		
	
		
		return resp;
	}

	/**
	 * Metodo para formar el valor de la propiedad api:where
	 * @param filtrosEndpoint
	 * @param entidad
	 * @return
	 */
	private String crearApiWhere(ArrayList<String> filtrosEndpoint,
			String entidad) {
		//     \' Comilla simple
		//  \" Comilla doble
		//String resp = ('?item rdf:type <"+entidad.trim()+">. filter(regex(str(?item),CONCAT( \"/"+filtrosEndpoint.get(0).trim()+"/\" ) '+'d');
		//resp += " \'?item rdf:type <"+entidad.trim()+">. filter(regex(str(?item),CONCAT( \"/"+filtrosEndpoint.get(0).trim()+"/\" ) ";
		String resp= "";
		if(filtrosEndpoint.isEmpty()){
			System.out.println("vacio apiwhere");simboloSeparar= "/";
		}else{
			String primera = simboloSeparar+filtrosEndpoint.get(0).trim()+simboloSeparar;  // String primera = "/"+filtrosEndpoint.get(0).trim()+"/"; 
			resp += "\' ?item rdf:type <"+entidad.trim()+">. filter(regex(str(?item),CONCAT( \""+primera+"\" ";
			int band=0;
			for (int i=1; i <= filtrosEndpoint.size() ;i++){
				resp += ", ?s"+i ;
				band++;
			}
			 if(band==0){
				 resp+=simboloSeparar+"{s1}";  //resp+="/{s1}";  
				 }
			resp += ", \"i\" )) \'" ;   //", \"i\"  \39 )) \' " ;
			
			System.out.println(resp);
			//resp = resp.replace('\', "");//limpiar string
	}
		return resp;
		
	}

	/**
	 * Metodo para formar el valor de la propiedad UriTemplate
	 * @param filtrosEndpoint
	 * @return
	 */
	private String crearUriTemplate(ArrayList<String> filtrosEndpoint) {
		String resp= "";simboloSeparar= "/";
		if(filtrosEndpoint.isEmpty()){
			System.out.println("vacio filtrosEndpoint");
		}else{
			 resp = simboloSeparar +filtrosEndpoint.get(0); //resp = "/"+filtrosEndpoint.get(0);
			int band=0;
			for (int i=1; i <= filtrosEndpoint.size() ;i++){
				resp += simboloSeparar+"{s"+i +"}"; //resp += "/{s"+i +"}";
				band++;
			}
			 if(band==0){
				 resp+= simboloSeparar+"{s1}"; // resp+="/{s1}";
			 }
		}
		return resp;
	}
	
	/**
	 * Metodo para realizar el muestreo y recuperar una lista con la respuesta , primera posicion parte comun
	 * @param listaMuestreo
	 * @param ebaseUri
	 * @return
	 */
	private ArrayList<String> obtenerParametrosFiltros( ArrayList<String> listaMuestreo, String ebaseUri) {
		//limpiar nulos 
		for (int j=0;j<listaMuestreo.size();j++) {
		      if (listaMuestreo.get(j) == null) { listaMuestreo.remove(j);}
		 }
		//obtener el size minimo de toda la lista
		int sizeminMuestreo =listaMuestreo.get(0).length();
		for (int j=0;j<listaMuestreo.size();j++) {
		     
			if (listaMuestreo.get(j).length()<sizeminMuestreo){
				sizeminMuestreo=listaMuestreo.get(j).length();
			}
			
		 }
		
		
		//muestreo
		
		int posBaseUri = ebaseUri.length(); //posicion final uri base
		int ultimaPosicionIgual=ebaseUri.length();
		for (int i=posBaseUri;i<sizeminMuestreo-1;i++){
			ArrayList<String> listaCaracteres = new ArrayList<String>();
			for (int j=0;j<listaMuestreo.size();j++) { //saco una posicion especifica de toda la lista de muestreo
		    
				listaCaracteres.add(listaMuestreo.get(j).substring(i, i+1)); 
			
		 	}
			// para saber si eran iguales les paso a un estructura que elimina duplicados
			HashSet hs = new HashSet();
			hs.addAll(listaCaracteres); //elimino repetidos
			if (hs.size()==1){ //si queda el size en 1 eran iguales
				ultimaPosicionIgual=i+1; //hasta donde extraigo
				System.out.println(" /////////PALABRAS FILTROS  ULTIMA  POSICION IGUAL " + i );
			}
			/*
			for (int j=0; j < listaCaracteres.size() -1 ;j++){ //comparo todos los caracteres extraidos de esa posicion
				if (listaCaracteres.get(j).compareTo(listaCaracteres.get(j+1))==0){
					ultimaPosicionIgual=i;					
				}else{
					break; //si ya es igual uno salgo de la comparacion
				}
				
			}*/
		}
		String entidadUri = listaMuestreo.get(0);
		System.out.println(" /////////PALABRAS FILTROS  PARTE IGUAL  /// "+entidadUri.substring(posBaseUri, ultimaPosicionIgual));
		
		ArrayList<String> resp = new ArrayList<String>() ;
		//String entidadUri = listaMuestreo.get(0);
		//int posBaseUri = ebaseUri.length(); //posicion uri base
		 simboloSeparar = "/";
		//if (listaMuestreo.get(0).contains("%")){
		//	simboloSeparar = "%";		
		//}else 
		if (listaMuestreo.get(0).contains("#")) {
			simboloSeparar = "#";
		}
		System.out.println(" /////////simbolo   /// " + simboloSeparar);
		
		int posAntesId = listaMuestreo.get(0).lastIndexOf(simboloSeparar) ; //posicion antes ultimo /
		ArrayList<Integer> indices = new ArrayList<Integer>();   //indices para separar
		
		if (posBaseUri < posAntesId){ //validacion
		
			//separar
			String parteAnalizar = entidadUri.substring(posBaseUri, posAntesId);
			if (!parteAnalizar.contains("/")){simboloSeparar = "#";}else{simboloSeparar = "/";}
			List<String> myList = new ArrayList<String>(Arrays.asList(parteAnalizar
					.split(simboloSeparar)));
			
			System.out.println(" /////////PALABRAS FILTROS   /// "+myList.toString());
			resp =  (ArrayList<String>) myList;
		}	

		
		return resp;
	}
	
	   public String quitaEspacios(String texto) {
		   texto = texto.replaceAll(" ","");
		   texto = texto.replaceAll("  ","");
	       /*
		   java.util.StringTokenizer tokens = new java.util.StringTokenizer(texto);
	        StringBuilder buff = new StringBuilder();
	        while (tokens.hasMoreTokens()) {
	            buff.append(" ").append(tokens.nextToken());
	        }
	        */
	        return texto.trim();
	    }

	/**
	 * This method is called by PDI once the step is done processing.
	 * 
	 * The dispose() method is the counterpart to init() and should release any
	 * resources acquired for step execution like file handles or database
	 * connections.
	 * 
	 * The meta and data implementations passed in can safely be cast to the
	 * step's respective implementations.
	 * 
	 * It is mandatory that super.dispose() is called to ensure correct
	 * behavior.
	 * 
	 * @param smi
	 *            step meta interface implementation, containing the step
	 *            settings
	 * @param sdi
	 *            step data interface implementation, used to store runtime
	 *            information
	 */
	public void dispose(StepMetaInterface smi, StepDataInterface sdi) {

		// Casting to step-specific implementation classes is safe
		EldaPDIStepMeta meta = (EldaPDIStepMeta) smi;
		EldaPDIStepData data = (EldaPDIStepData) sdi;

		super.dispose(meta, data);
	}

	private void recursiveCopy(File fSource, File fDest) {
		try {
			if (fSource.isDirectory()) {
				// A simple validation, if the destination is not exist then
				// create it
				if (!fDest.exists()) {
					fDest.mkdirs();
				}

				// Create list of files and directories on the current source
				// Note: with the recursion 'fSource' changed accordingly
				String[] fList = fSource.list();

				for (int index = 0; index < fList.length; index++) {
					File dest = new File(fDest, fList[index]);
					File source = new File(fSource, fList[index]);

					// Recursion call take place here
					recursiveCopy(source, dest);
				}
			} else {
				// Found a file. Copy it into the destination, which is already
				// created in 'if' condition above
				fSource.setExecutable(true); // code to set permises

				// Open a file for read and write (copy)
				FileInputStream fInStream = new FileInputStream(fSource);
				FileOutputStream fOutStream = new FileOutputStream(fDest);

				// Read 2K at a time from the file
				byte[] buffer = new byte[2048];
				int iBytesReads;

				// In each successful read, write back to the source
				while ((iBytesReads = fInStream.read(buffer)) >= 0) {
					fOutStream.write(buffer, 0, iBytesReads);

				}

				// Safe exit
				if (fInStream != null) {
					fInStream.close();
				}

				if (fOutStream != null) {
					fOutStream.close();
				}

				fDest.setExecutable(true); // code to set permises
			}
		} catch (Exception ex) {
			// Please handle all the relevant exceptions here
			logBasic(" ERROR " + ex + "in create output directory ");
		}
		
		//
	} // fin recursivy copy
	
	public void parametrizarUri(File fSource, File fDest, String nombre){
		logBasic(" config web.xml value "+nombre+ " in "+fDest);
			 try
	         {
				 //File file = new File(fSource+"/webapps/standalone/WEB-INF/web.xml");
	         File file = new File(fSource+"/webapps/ROOT/WEB-INF/web.xml");
	         BufferedReader reader = new BufferedReader(new FileReader(file));
	         String line = "", oldtext = "";
	         while((line = reader.readLine()) != null)
	             {
	             oldtext += line + "\r\n";
	         }
	         reader.close();

	         String phase  = oldtext.replaceAll("nuevoparametro", nombre+"::specs/"+nombre+".ttl");

	         FileWriter writer = new FileWriter(fDest+"/webapps/ROOT/WEB-INF/web.xml"); // FileWriter writer = new FileWriter(fDest+"/webapps/standalone/WEB-INF/web.xml");
	         writer.write(phase);


	         writer.close();

	     }
	     catch (IOException ioe)
	         {
	         ioe.printStackTrace();
	         logBasic(" ERROR " + ioe + "in add parametro in web.xml. ");
	     }
					
		
	}
	/**
	 * Metodo para obtener un muestreo de por entidad
	 * @param Servicio
	 * @param grafoUri
	 * @param Entidad
	 * @return
	 */
	
	public ArrayList ObtenerListaMuestreo(String Servicio, String grafoUri,
			String Entidad) {

		ArrayList<String> mili = new ArrayList<String>();
		if (chekearServicioMuestreo(Servicio)) {
			String queryString = "PREFIX  rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
					+ " select distinct ?s "
					+ "FROM    <"
					+ grafoUri.trim()
					+ ">"
					+ " WHERE {"
					+ " ?s rdf:type <"
					+ Entidad.trim()
					+ ">  } LIMIT 10 ";
			if (grafoUri.trim().isEmpty()) { // si esta vacio busco sin graph
				queryString = "PREFIX  rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
						+ " select distinct ?s "
						+ " WHERE {"
						+ " ?s rdf:type <" + Entidad.trim() + ">  } LIMIT 10 ";
			}

			Query query = QueryFactory.create(queryString);
			QueryExecution qexec = QueryExecutionFactory.sparqlService(
					Servicio, query);
			System.out.println(" servicio  " + Servicio + "query " + query);

			try {
				ResultSet results = qexec.execSelect();
				ArrayList<QuerySolution> solutions = new ArrayList<QuerySolution>();
				solutions = (ArrayList<QuerySolution>) ResultSetFormatter
						.toList(results);
				solutions.toArray();
				// Output query results
				ResultSetFormatter.out(System.out, results, query);
				if (solutions.size() > 0) { // validacion lista vacia
					System.out
					.println("accediendo consulta muestreo entidades ");
					solutions.get(0).get("?s");

					for (int i = 0; i < solutions.size(); i++) {
						mili.add(solutions.get(i).get("?s").toString());

						System.out
								.println( solutions.get(i).get("?s").toString());
					}
				}
				throw new MalformedURLException("s");
			} catch (MalformedURLException d) {
				logBasic(" ERROR " + d.getMessage() + "BAD url");
			} finally {
				qexec.close();
			}
		}
		return mili;
	}
	
	/**
	 * Metodo para obtener los tipos de URI  por entidad
	 * @param Servicio
	 * @param grafoUri
	 * @param Entidad
	 * @return
	 */
	
	public ArrayList ObtenerTiposEntidad(String Servicio, String grafoUri,
			String Entidad) {

		ArrayList<String> mili = new ArrayList<String>();
		if (chekearServicioMuestreo(Servicio)) {
			String queryString = "PREFIX  rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
					+ " select distinct ?a "
					+ "FROM    <"
					+ grafoUri.trim()
					+ ">"
					+ " WHERE {"
					+ " ?s ?a ?o . ?o a <"
					+ Entidad.trim()
					+ ">  } LIMIT 20 ";
			if (grafoUri.trim().isEmpty()) { // si esta vacio busco sin graph
				queryString = "PREFIX  rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
						+ " select distinct ?a "
						+ " WHERE {"
						+ " ?s ?a ?o . ?o a <"
						+ Entidad.trim()
						+ ">  } LIMIT 20 ";
			}

			Query query = QueryFactory.create(queryString);
			QueryExecution qexec = QueryExecutionFactory.sparqlService(
					Servicio, query);
			System.out.println(" servicio  " + Servicio + "query " + query);

			try {
				ResultSet results = qexec.execSelect();
				ArrayList<QuerySolution> solutions = new ArrayList<QuerySolution>();
				solutions = (ArrayList<QuerySolution>) ResultSetFormatter
						.toList(results);
				solutions.toArray();
				// Output query results
				ResultSetFormatter.out(System.out, results, query);
				if (solutions.size() > 0) { // validacion lista vacia
					System.out
					.println("accediendo consulta tipos de Uri por entidad ");
					solutions.get(0).get("?a");

					for (int i = 0; i < solutions.size(); i++) {
						mili.add(solutions.get(i).get("?a").toString());

						System.out
								.println( solutions.get(i).get("?a").toString());
					}
				}
				throw new MalformedURLException("s");
			} catch (MalformedURLException d) {
				//logBasic(" ERROR " + d.getMessage() );
			} finally {
				qexec.close();
			}
		}
		return mili;
	}
	
	
	/**
	 * Metodo para obtener las Uri de entidad por tipo de entidad enviado;
	 * @param Servicio
	 * @param grafoUri
	 * @param UriTipoEntidad
	 * @return
	 */
	
	public ArrayList ObtenerMuestreoXTipoEntidad(String Servicio, String grafoUri,
			String UriTipoEntidad) {

		ArrayList<String> mili = new ArrayList<String>();
		if (chekearServicioMuestreo(Servicio)) {
			String queryString = "PREFIX  rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
					+ " select distinct ?o "
					+ "FROM    <"
					+ grafoUri.trim()
					+ ">"
					+ " WHERE {"
					+ " ?s  <"+ UriTipoEntidad.trim()
					+ ">  ?o} LIMIT 10 ";
			if (grafoUri.trim().isEmpty()) { // si esta vacio busco sin graph
				queryString = "PREFIX  rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
						+ " select distinct ?o "
						+ " WHERE {"
						+ " ?s  <"+ UriTipoEntidad.trim()
						+ ">  ?o} LIMIT 10 ";
			}

			Query query = QueryFactory.create(queryString);
			QueryExecution qexec = QueryExecutionFactory.sparqlService(
					Servicio, query);
			System.out.println(" servicio  " + Servicio + "query " + query);

			try {
				ResultSet results = qexec.execSelect();
				ArrayList<QuerySolution> solutions = new ArrayList<QuerySolution>();
				solutions = (ArrayList<QuerySolution>) ResultSetFormatter
						.toList(results);
				solutions.toArray();
				// Output query results
				ResultSetFormatter.out(System.out, results, query);
				if (solutions.size() > 0) { // validacion lista vacia
					System.out
					.println("accediendo consultar muestreo por tipos de entidad ");
					solutions.get(0).get("?o");

					for (int i = 0; i < solutions.size(); i++) {
						mili.add(solutions.get(i).get("?o").toString());

						System.out
								.println( solutions.get(i).get("?o").toString());
					}
				}
				throw new MalformedURLException("s");
			} catch (MalformedURLException d) {
				//logBasic(" ERROR " + d.getMessage() );
			} finally {
				qexec.close();
			}
		}
		return mili;
	}
	
	/**
	 * Validar que el servicio este levantado
	 * @param Servicio
	 * @return
	 */
	public Boolean chekearServicioMuestreo (String Servicio){
		Boolean resp = false ;
		Boolean urlCorrecto = true;
		Boolean urlAcceso = true;
		try {
		    URL url = new URL(Servicio.trim());
		    URLConnection conn = url.openConnection();
		    conn.connect();
		} catch (MalformedURLException e) {  // URL mal formada 
			logBasic(" ////MUESTREO URL "+Servicio+  " malformada "); 
			System.out.println("////MUESTREO URL "+Servicio+  " malformada ");
		   urlCorrecto = false ;

		   
		} catch (IOException e) {   // no hay conexion
			logBasic("////MUESTREO Servicio a consultar caido "+Servicio);
			System.out.println("////MUESTREO Servicio a consultar caido "+Servicio);
			urlAcceso = false ;

			
		}
		
		if (urlCorrecto && urlAcceso){ //cuando hay servicio procedo a consultar 
			resp= true;
		}
		
		return resp;
	}

	private void crearwar(String direc) {

		File buildFile = new File(
				"\\plugins\\steps\\EldaLoader\\axis_bujava.xml");
		// File buildFile = new
		// File("/plugins/steps/FusekiLoader/axis_bujava.xml");

		Project antProject = new Project();

		DefaultLogger consoleLogger = new DefaultLogger();
		consoleLogger.setErrorPrintStream(System.err);
		consoleLogger.setOutputPrintStream(System.out);
		consoleLogger.setMessageOutputLevel(Project.MSG_INFO);
		antProject.addBuildListener(consoleLogger);
		try {
			antProject.fireBuildStarted();

			antProject.setUserProperty("ant.file", buildFile.getAbsolutePath());
			antProject.init();
			ProjectHelper helper = ProjectHelper.getProjectHelper();
			antProject.addReference("ant.ProjectHelper", helper);
			helper.parse(antProject, buildFile);
			String target = "build-war";
			antProject.setUserProperty("build.dir", direc);
			antProject.executeTarget(target);

			antProject.fireBuildFinished(null);
		} catch (BuildException e) {
			antProject.fireBuildFinished(e);
			logBasic(" ERROR " + e);

		}

	}

	

	public List<String> cleanspaces(String limpiar) {

		// logError("nameontology "+meta.getNameOntology());
		String replace = limpiar.replace("[", "");

		String replace1 = replace.replace("]", "");

		String replace2 = replace1.replaceAll("\\s+", "");

		List<String> myList = new ArrayList<String>(Arrays.asList(replace2
				.split(",")));

		return myList;
	}
	
	
	public ArrayList<String> cargaListaTodos(String limpiar) {
		//no borra vacios
		// logError("nameontology "+meta.getNameOntology());
		System.out.println("/////////////////////////////////////////////////////////////////1") ;
		System.out.println("//////// LIMPIAR " + limpiar) ;
		String replace = limpiar.replace("[", "");

		String replace1 = replace.replace("]", "");
		System.out.println("//////// replace1 " + replace1) ;
		

		ArrayList<String> myList = new ArrayList<String>(Arrays.asList(replace1
				.split(",")));
		
		System.out.println("//////// lista size" + myList.size()) ;

		System.out.println("/////////////////////////////////////////////////////////////////2") ;
		return myList;
	}


}
